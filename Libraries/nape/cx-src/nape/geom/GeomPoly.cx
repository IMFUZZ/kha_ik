package nape.geom;
$(import);

// caxe only 'typedef'
$(mixin Vertex() PR(GeomVert));

// Using geometry environment
geom(

!!/**
!! * Polygon class with various geometric methods
!! * <br/><br/>
!! * This class represents a general Polygon, rather than the Polygon class
!! * which is physics shape.
!! * <br/><br/>
!! * Internally this polygon is stored as a circularly linked list of special
!! * vertex types that are exposed via a Vec2 that is lazily constructed whenever
!! * necessary to the API.
!! */
@:final class GeomPoly {

    // caxe only alias for vertex list
    $(mixin verts() pr(inner).vertices);

    // GeomPoly is poolable as a public object.
    PublicMixPool(GeomPoly)

    !!/**
    !! * @private
    !! */
    public var pr(inner):PR(GeomPoly) = null;

    !!/**
    !! * Determine if polygon is empty.
    !! *
    !! * @return True if polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function empty():Bool {
        Disposed(this, GeomPoly);
        return mix_circular(Vertex, empty(verts));
    }

    !!/**
    !! * Determine number of vertices in polygon
    !! *
    !! * @return The number of vertices.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function size():Int {
        Disposed(this, GeomPoly);
        return mix_circular(Vertex, size(verts));
    }

    !!/**
    !! * Haxe iterator over vertices of polygon.
    !! *
    !! * @return A Haxe iterator over the vertices of the polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function iterator():GeomVertexIterator {
        Disposed(this, GeomPoly);
        return PR(GeomVertexIterator).get(verts, true);
    }

    !!/**
    !! * Haxe iterator over vertices of polygon.
    !! *
    !! * @return A Haxe iterator over the vertices of the polygon.
    !! *         Iterating in a forward direction.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function forwardIterator():GeomVertexIterator {
        Disposed(this, GeomPoly);
        return PR(GeomVertexIterator).get(verts, true);
    }

    !!/**
    !! * Haxe iterator over vertices of polygon.
    !! *
    !! * @return A Haxe iterator over the vertices of the polygon.
    !! *         Iterating in a backwards direction.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function backwardsIterator():GeomVertexIterator {
        Disposed(this, GeomPoly);
        return PR(GeomVertexIterator).get(verts, false);
    }

    !!/**
    !! * Current vertex at head of polygon.
    !! * <br/><br/>
    !! * The current vertex will not be changed by this access.
    !! * <br/><br/>
    !! * This function returns a Vec2 which will be intrinsically tied
    !! * to the values of the internal vertex so that modifications to
    !! * this Vec2 will be reflected in the vertex of the polygon.
    !! * <br/><br/>
    !! * If invoked again with the head of the polygon pointing to the
    !! * same vertex, then the same Vec2 will be returned; this Vec2 is
    !! * not able to be disposed of.
    !! *
    !! * @return A Vec2 representing the current vertex of polygon.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function current():Vec2 {
        Disposed(this, GeomPoly);
        DEBUG(
            if (empty()) {
                throw "Error: GeomPoly is empty";
            }
        )

        return verts.wrapper();
    }

    !!/**
    !! * Push vertex to polygon.
    !! * <br/><br/>
    !! * A vertex will be allocated from a global object pool, and initialised
    !! * with the values of the given Vec2.
    !! * <br/><br/>
    !! * This vertex will be inserted after the current head, and the head
    !! * advanced to the newly inserted vertex, in this way successive pushes
    !! * will insert elements in order.
    !! * <br/><br/>
    !! * Note that the Vec2 supplied as argument is only used to initialise the
    !! * inner Vertex.
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! *
    !! * poly.push(X);
    !! *
    !! * poly := -> A <-> B <-> X <-> C <-> D <-> E <-
    !! *                      (head)
    !! * </pre>
    !! *
    !! * @param vertex The Vec2 to be used in initialising the inner vertex.
    !! * @return A reference to this polygon.
    !! * @throws # If Vec2 is null, or has been disposed.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function push(vertex:Vec2):GeomPoly {
        Disposed(this, GeomPoly);
        Disposed(vertex, Vec2);
        DEBUG(
            if (vertex == null) {
                throw "Error: Cannot push null vertex";
            }
        )

        mix_circular(Vertex,
            verts = push_after(verts, Vertex.get(vertex.x, vertex.y));
        )

        WEAK(vertex);
        return this;
    }

    !!/**
    !! * Pop vertex from polygon.
    !! * <br/><br/>
    !! * Pop the current vertex at head of polygon, retreating the 'current'
    !! * vertex to point to the previous vertex in polygon. This inner vertex
    !! * will be released to the global object pool.
    !! * <br/><br/>
    !! * In this way a pop which follows a push will act to reset the push.
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! *
    !! * poly.pop();
    !! *
    !! * poly := -> A <-> C <-> D <-> E <-
    !! *          (head)
    !! * </pre>
    !! *
    !! * @return A reference to this polygon.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function pop():GeomPoly {
        Disposed(this, GeomPoly);
        mix_circular(Vertex,
            DEBUG(
                if (empty(verts)) {
                    throw "Error: Cannot pop from empty polygon";
                }
            )

            var retv = verts;
            verts = pop_ret_before(verts);
            Free(Vertex, retv);
        )

        return this;
    }

    !!/**
    !! * Unshift vertex to polygon.
    !! * <br/><br/>
    !! * A vertex will be allocated from a global object pool, and initialised
    !! * with the values of the given Vec2.
    !! * <br/><br/>
    !! * This vertex will be inserted before the current head, and the head
    !! * retreated to the newly inserted vertex, in this way successive unshifts
    !! * will insert elements in the expected reverse order.
    !! * <br/><br/>
    !! * Note that the Vec2 supplied as argument is only used to initialise the
    !! * inner Vertex.
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! *
    !! * poly.unshift(X);
    !! *
    !! * poly := -> A <-> X <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! * </pre>
    !! *
    !! * @param vertex The Vec2 to be used in initialising the inner vertex.
    !! * @return A reference to this polygon.
    !! * @throws # If Vec2 is null, or has been disposed.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function unshift(vertex:Vec2):GeomPoly {
        Disposed(vertex, Vec2);
        DEBUG(
            if (vertex == null) {
                throw "Error: Cannot unshift null vertex";
            }
        )

        mix_circular(Vertex,
            verts = push_before(verts, Vertex.get(vertex.x,vertex.y));
        )

        WEAK(vertex);
        return this;
    }

    !!/**
    !! * Shift vertex from polygon.
    !! * <br/><br/>
    !! * Shift the current vertex at head of polygon, advancing the 'current'
    !! * vertex to point to the next vertex in polygon. This inner vertex
    !! * will be released to the global object pool.
    !! * <br/><br/>
    !! * In this way a shift which follows an unshift will act to reset the
    !! * unshift operation.
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! *
    !! * poly.shift();
    !! *
    !! * poly := -> A <-> C <-> D <-> E <-
    !! *                (head)
    !! * </pre>
    !! *
    !! * @return A reference to this polygon.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function shift():GeomPoly {
        Disposed(this, GeomPoly);
        mix_circular(Vertex,
            DEBUG(
                if (empty(verts)) {
                    throw "Error: Cannot shift from empty polygon";
                }
            )

            var retv = verts;
            verts = pop_ret_after(verts);
            Free(Vertex,retv);
        )

        return this;
    }

    !!/**
    !! * Advance head of polygon forward.
    !! * <br/><br/>
    !! * The current head of polygon will be moved forwards
    !! * the given number of times, with a negative value
    !! * being equivalent to performing a backwards advance.
    !! * <br/><br/>
    !! * <code>poly.skip_forwards(times)</code> is equivalent to
    !! * <code>poly.skip_backwards(-times)</code>
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! *
    !! * poly.skipForwards(2);
    !! *
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                            (head)
    !! * </pre>
    !! *
    !! * @params times The number of times to advance head forward.
    !! *               This value can be negative indicating a backwards
    !! *               advance.
    !! * @return A reference to this polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function skipForward(times:Int):GeomPoly {
        Disposed(this, GeomPoly);
        mix_circular(Vertex,
            if (!empty(verts)) {
                if (times>0) {
                    while(times-- > 0) verts = verts.next;
                }elif (times<0) {
                    while(times++ < 0) verts = verts.prev;
                }
            }
        )

        return this;
    }

    !!/**
    !! * Advance head of polygon backwards.
    !! * <br/><br/>
    !! * The current head of polygon will be moved backwards
    !! * the given number of times, with a negative value
    !! * being equivalent to performing a forwards advance.
    !! * <br/><br/>
    !! * <code>poly.skip_backwards(times)</code> is equivalent to
    !! * <code>poly.skip_forwards(-times)</code>
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! *
    !! * poly.skipBackwards(2);
    !! *
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                                  (head)
    !! * </pre>
    !! *
    !! * @params times The number of times to advance head backwards.
    !! *               This value can be negative indicating a forwards
    !! *               advance.
    !! * @return A reference to this polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function skipBackwards(times:Int) {
        Disposed(this, GeomPoly);
        return skipForward(-times);
    }

    !!/**
    !! * Erase count number of elements
    !! * <br/><br/>
    !! * For positive values of count, this is equivalent to successive
    !! * unshift operations.
    !! * <br/><br/>
    !! * For negative values of count, this is equivalent to successive
    !! * pop operations.
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-> F <-> G <-
    !! *                (head)
    !! *
    !! * poly.erase(2);
    !! *
    !! * poly := -> A <-> D <-> E <-> F <-> G <-
    !! *                (head)
    !! *
    !! * poly.erase(-3);
    !! *
    !! * poly := -> E <-> F <-
    !! *                (head)
    !! * </pre>
    !! * In this case that the specified number of elements to erase is
    !! * greater than the size of the polygon, the method will simply
    !! * terminate with the polygon being empty.
    !! *
    !! * @param count The number of vertices to erase, with sign indicating
    !! *              the direction for erasing.
    !! * @return A reference to this polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function erase(count:Int):GeomPoly {
        Disposed(this, GeomPoly);
        mix_circular(Vertex,
            while (count != 0 && !empty(verts)) {
                var retv = verts;
                if (count > 0) {
                    verts = pop_ret_after(verts);
                    count--;
                }
                elif (count < 0) {
                    verts = pop_ret_before(verts);
                    count++;
                }
                Free(Vertex, retv);
            }
        )

        return this;
    }

    !!/**
    !! * Clear all vertices from polygon.
    !! * <br/><br/>
    !! * All of the vertices will be released to the global object pool.
    !! *
    !! * @return A reference to this polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function clear():GeomPoly {
        Disposed(this, GeomPoly);
        mix_circular(Vertex,
            clear_with(verts, $(mixin cb(x) Free(Vertex, x)) cb);
        )

        return this;
    }

    !!/**
    !! * Copy this polygon.
    !! * <br/><br/>
    !! * The copy will have its vertices in the same order as 'this' polygon.
    !! * It will also have its current vertex at head, as the same vertex
    !! * this polygon has.
    !! * <br/><br/>
    !! * This polygon will not be modified in any way.
    !! * <pre>
    !! * poly := -> A <-> B <-> C <-> D <-> E <-
    !! *                (head)
    !! *
    !! * poly2 = poly.copy();
    !! *
    !! * poly2 := -> A' <-> B' <-> C' <-> D' <-> E' <-
    !! *                  (head)
    !! * </pre>
    !! *
    !! * @return The new GeomPoly representing the copy.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function copy():GeomPoly {
        Disposed(this, GeomPoly);
        var ret = GeomPoly.get();
        mix_circular(Vertex,
            for_iter(v, verts, {
                ret.verts = push_after(ret.verts, Vertex.get(v.x,v.y));
            });
        )

        return ret.skipForward(1);
    }

    !!/**
    !! * Create a new GeomPoly polygon.
    !! * <br/><br/>
    !! * The vertices argument is typed Dynamic (* in AS3), and is permitted
    !! * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
    !! * <br/><br/>
    !! * The input will be used to initialise the vertices of the polygon with
    !! * the head of the polygon pointing to the first vertex in input with vertices
    !! * inserted in forward order.
    !! * <br/><br/>
    !! * You should use the static 'get' method in preference to make use of object pool.
    !! *
    !! * @param vertices Vertex data to initialise polygon, or null for empty polygon.
    !! * @return New GeomPoly representing input vertex data.
    !! * @throws # If input data is not of an expected Type.
    !! */
    public function new(vertices:Dynamic = null) {
        pr(inner) = new PR(GeomPoly)(this);
        if(vertices != null) {
            PolyIter(v, vertices, {
                mix_circular(Vertex,
                    verts = push_after(verts, Vertex.get(v.x, v.y));
                )
            });
            skipForward(1);
            PolyWeak(vertices);
        }
    }

    !!/**
    !! * Allocate GeomPoly from object pool.
    !! * <br/><br/>
    !! * The vertices argument is typed Dynamic (* in AS3), and is permitted
    !! * to be one of: <code>Array&lt;Vec2&gt;, flash.Vector&lt;Vec2&gt;, Vec2List, GeomPoly</code>
    !! * <br/><br/>
    !! * The input will be used to initialise the vertices of the polygon with
    !! * the head of the polygon pointing to the first vertex in input with vertices
    !! * inserted in forward order.
    !! *
    !! * @param vertices Vertex data to initialise polygon, or null for empty polygon.
    !! * @return New GeomPoly representing input vertex data, allocated from object pool.
    !! * @throws # If input data is not of an expected Type.
    !! */
    public static function get(vertices:Dynamic = null) {
        var ret; PublicGet(GeomPoly, ret);
        if(vertices != null) {
            PolyIter(v, vertices, {
                mix_circular(Vertex,
                    ret.verts = push_after(ret.verts, Vertex.get(v.x, v.y));
                )
            });
            ret.skipForward(1);
            PolyWeak(vertices);
        }
        return ret;
    }

    !!/**
    !! * Release this GeomPoly to global object pool.
    !! * <br/><br/>
    !! * Once disposed this GeomPoly will be accessible to Nape internals for re-allocation
    !! * and should not be touched (Good practice would be to set any references to this
    !! * GeomPoly to null to help ensure this).
    !! * <br/><br/>
    !! * In debug mode, should you attempt to access this GeomPoly after disposal
    !! * and the GeomPoly is still in the object pool, you will be given an Error.
    !! * The object pool operates on a First-In-Last-Out principal in debug mode to help
    !! * catch these sort of errors.
    !! * @throws # If this GeomPoly has already been disposed.
    !! */
    public function dispose():Void {
        Disposed(this, GeomPoly);

        // Release vertices to object pool.
        clear();
        PublicFree(GeomPoly, this);
    }

    !!/**
    !! * @private
    !! */
    @:$keep public function toString():String {
        var ret = "GeomPoly[";
        mix_circular(PR(GeomVert),{
            for_iter(v, verts, {
                if (v != verts) ret += ",";
                ret += "{"+v.x+","+v.y+"}";
            });
        })
        return ret+"]";
    }

    $(mixin size_lt_3() ({
        verts == null || verts.next == null || verts.prev == verts.next;
    }));

    !!/**
    !! * Compute area of weakly-simple polygon.
    !! * <br/><br/>
    !! * For complex polygons, this function will return an underestimate
    !! * to the true area.
    !! *
    !! * @return The area of the polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function area():Float {
        Disposed(this, GeomPoly);
        return if (size_lt_3) 0.0 else area(verts);
    }

    !!/**
    !! * Compute the winding order for this polygon.
    !! * <br/><br/>
    !! * The winding order can be conceptualised by thinking of an analog
    !! * clock face, if your polygon is the numbers on the clock then a
    !! * clockwise winding would have your polygon's vertices in numerical
    !! * order.
    !! * <br/><br/>
    !! * In the case of a non-simple polygon with self intersections then the
    !! * winding order is decided by how 'much' of the polygon is locally
    !! * clockwise wound, and how much is locally anti-clockwise wound.
    !! * <br/>
    !! * (Think of a figure 8 style polygon where one loop is larger than the
    !! * other. This larger loop will dictate the winding of the polygon.)
    !! * <br/><br/>
    !! * If no winding can be computed, then <code>Winding.UNDEFINED</code>
    !! * will be returned.
    !! *
    !! * @return The winding of the polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function winding():Winding {
        Disposed(this, GeomPoly);
        if (size_lt_3) {
            return Winding.UNDEFINED;
        }
        else {
            var area = signed_area(verts);
            return if  (area >0) Winding.CLOCKWISE
                   elif(area==0) Winding.UNDEFINED
                   else          Winding.ANTICLOCKWISE;
        }
    }

    !!/**
    !! * Determine if point is contained in polygon.
    !! * <br/><br/>
    !! * Polygon containment is performed with a ray cast through polygon
    !! * from the vertex and counting the number of intersections. In this
    !! * way containment will be defined for self-intersecting polygons based
    !! * on how such a polygon would be rendered with areas of self-intersection
    !! * treat as being 'outside' the polygon.
    !! * <br/><br/>
    !! * This algorithm operates in O(n) time.
    !! *
    !! * @param point The point to test for containment.
    !! * @return True if point is contained in the polygon.
    !! * @throws # If point is null or has been disposed.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function contains(point:Vec2):Bool {
        Disposed(this, GeomPoly);
        Disposed(point,Vec2);
        DEBUG(
            if (point == null) {
                throw "Error: GeomPoly::contains point cannot be null";
            }
        )

        var ret = contains(verts, point.x, point.y);

        WEAK(point);
        return ret;
    }

    !!/**
    !! * Determine if polygon is clockwise wound.
    !! * <br/><br/>
    !! * This is equivalent to <code>poly.winding() == Winding.CLOCKWISE</code>.
    !! *
    !! * @return True if polygon is clockwise wound.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function isClockwise():Bool {
        return winding() == Winding.CLOCKWISE;
    }

    !!/**
    !! * Determine if weakly-simple polygon is convex.
    !! * <br/><br/>
    !! * This algorithm assumes that the polygon is weakly-simple. Otherwise it may
    !! * fail (It is very easy to construct a self intersecting polygon which
    !! * will return True for isConvex()).
    !! * <br/><br/>
    !! * You may wish to instead use <code>isSimple() && isConvex()</code> if
    !! * you cannot be sure of the polygon being simple, noting that this will
    !! * of course return false in the case of a weakly-simple polygon.
    !! * <pre>
    !! *  _____
    !! * |     |
    !! * |     |  <-- convex
    !! * |____/
    !! *  __
    !! * |  &#92;___
    !! * |     /  <-- concave
    !! * |____/
    !! * </pre>
    !! * This algorithm operates in O(n) time.
    !! *
    !! * @return True if polygon is found to be convex.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function isConvex():Bool {
        Disposed(this, GeomPoly);
        return if(size_lt_3) true else convex(verts);
    }

    !!/**
    !! * Determine if polygon is strictly simple.
    !! * <br/><br/>
    !! * By strict simplicity, we refer to not permitting 'glancing'
    !! * self intersections (where boundary of polygon 'touches' but does not
    !! * pass through another area of the polygon's boundary). This property
    !! * is instead referred to as being 'weakly simple' for which there is no
    !! * easy test!
    !! * <pre>
    !! *  _______
    !! * |   __  |  <-- strictly simple polygon.
    !! * |   &#92; &#92;_|
    !! *  &#92;__/
    !! *  _______
    !! * |   |   |
    !! * |  /_&#92;  | <-- weakly simple polygon.
    !! *  &#92;_____/
    !! *  ____
    !! * | __/
    !! *  X_  __   <-- complex polygon.
    !! * |  &#92;/  &#92;
    !! * &#92;__/&#92;__|
    !! * </pre>
    !! * This algorithm operates in O(n.log(n)) time.
    !! *
    !! * @return True if polygon is strictly simple.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function isSimple():Bool {
        Disposed(this, GeomPoly);
        return if(size_lt_3) true else PR(Simple).isSimple(verts);
    }

    !!/**
    !! * Determine if polygon is y-monotone.
    !! * <br/><br/>
    !! * To be classed as y-monotone, the polygon must be such that any horizontal
    !! * line intersects the polygon in at most 2 intersections.
    !! * <pre>
    !! *  ___
    !! * |   |
    !! * |   |  <-- y-monotone
    !! * |___|
    !! *
    !! * |&#92;
    !! * | &#92;/|  <-- not y-monotone, offending vertex at bottom of the V.
    !! * |___|
    !! * </pre>
    !! * This algorithm operates in O(n) time.
    !! *
    !! * @return True if polygon is y-monotone.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function isMonotone():Bool {
        Disposed(this, GeomPoly);
        return if(size_lt_3) true else PR(Monotone).isMonotone(verts);
    }

    !!/**
    !! * Determine if weakly-simple polygon is degenerate.
    !! * <br/><br/>
    !! * Degeneracy is determined by having a zero area, if polygon is complex,
    !! * then this function may report degeneracy erroneously.
    !! *
    !! * @return True if polygon is degenerate.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public inline function isDegenerate():Bool {
        Disposed(this, GeomPoly);
        return if(size_lt_3) true else area() < Config.epsilon;
    }

    !!/**
    !! * Simplify polygon.
    !! * <br/><br/>
    !! * Simplification is performed with an implementation of the Ramer-Douglas-Peucker
    !! * algorithm. The output polygon is formed via subset of the vertices in
    !! * the input polygon such that any discarded vertex is at most 'epsilon' pixels
    !! * away from the local output polygon.
    !! * <br/><br/>
    !! * This algorithm works on both simple and complex polygons, but please note
    !! * that this algorithm makes no guarantees on a simple polygon remaining simple
    !! * after simplification. This should not generally be a problem unless the epsilon
    !! * value is large with respect to the size of the features on the polygon.
    !! * <br/><br/>
    !! * Many of the geometric algorithms will mark vertices as important, such that
    !! * they will be guaranteed to exist after simplification (Such as preventing
    !! * gaps from opening up in marching squares when simplifying output polygons).
    !! * <br/><br/>
    !! * The average runtime of this algorithm is O(n.log(n)). This algorithm is
    !! * not stable in the sense that adding a new vertex to the polygon may drastically
    !! * change the result of simplifying the polygon.
    !! *
    !! * @param epsilon The distance from polygon at which vertices are ignored.
    !! * @return A new GeomPoly representing the result of the simplification.
    !! * @throws # If epsilon is <= 0.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function simplify(epsilon:Float):GeomPoly {
        Disposed(this, GeomPoly);
        DEBUG(
            if(epsilon <= 0.0) {
                throw "Error: Epsilon should be > 0 for simplifying a GeomPoly";
            }
        )

        if(size_lt_3) {
            return copy();
        }
        else {
            var x = PR(Simplify).simplify(verts, epsilon);
            var ret = GeomPoly.get();
            ret.verts = x;
            return ret;
        }
    }

    !!/**
    !! * Produce a decomposition of complex polygon into simple components.
    !! * <br/><br/>
    !! * WARNING: This method is 'not' 100% robust. It may fail!
    !! * <br/><br/>
    !! * Produce a decomposition of a self intersecting, complex polygon into
    !! * a set of weakly-simple components.
    !! * <br/><br/>
    !! * This algorithm operates in O(n.log(n)) time and is based on the
    !! * Bentley-Ottmann algorithm.
    !! *
    !! * @param output If supplied, polygons will be appended to this list via 'add'
    !! *        instead of a new list being constructed.
    !! * @return A Nape list of GeomPoly's representing the decomposition.
    !! * @throws # If polygon is degenerate.
    !! * @throws # Any other error may be thrown if algorithm has failed, even
    !! *           in release builds!
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function simpleDecomposition(output:GeomPolyList=null):GeomPolyList {
        Disposed(this, GeomPoly);
        DEBUG(
            if(size_lt_3) {
                throw "Error: Cannot decompose a degenerate polygon";
            }
        )

        var MPs = PR(Simple).decompose(verts, PR(PartitionedPoly).getShared());
        var ret = (output == null ? new GeomPolyList() : output);
        while (!MPs.empty()) {
            var MP = MPs.pop_unsafe();
            var x = GeomPoly.get();
            x.verts = MP;
            ret.add(x);
        }

        return ret;
    }

    !!/**
    !! * Produce a decomposition of weakly-simple polygon into monotone components.
    !! * <br/><br/>
    !! * This algorithm 'should' be 100% robust and has been well tested on for
    !! * example, the output of the Marching Squares utility which produces many
    !! * degenerate cases of weakly-simple polygons that have not yet broken this
    !! * algorithm!.
    !! * <br/><br/>
    !! * This algorithm operates in O(n.log(n)) time and may strip vertices from
    !! * the polygon in degenerate cases where vertex is not needed to define the
    !! * polygon.
    !! * <br/><br/>
    !! * This algorithm is an improved version of the one presented in: Mark de
    !! * Berg, Marc van Kreveld, Mark Overmars, and Otfried Schwarzkopf.
    !! * Computational Geometry: Algorithms and Applications. Springer-Verlag,
    !! * Berlin, 1997.
    !!
    !! * @param output If supplied, polygons will be appended to this list via 'add'
    !! *        instead of a new list being constructed.
    !! * @return A Nape list of GeomPoly's defining the decomposition.
    !! * @throws # If polygon is degenerate.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function monotoneDecomposition(output:GeomPolyList=null):GeomPolyList {
        Disposed(this, GeomPoly);
        DEBUG(
            if(size_lt_3) {
                throw "Error: Cannot decompose a degenerate polygon";
            }
        )

        var poly = PR(Monotone).decompose(verts, PR(Monotone).getShared());
        var MPs = poly.extract(PR(PartitionedPoly).getShared());
        var ret = (output == null ? new GeomPolyList() : output);
        while (!MPs.empty()) {
            var MP = MPs.pop_unsafe();
            var x = GeomPoly.get();
            x.verts = MP;
            ret.add(x);
            assert(x.isMonotone(), "monotone decomposition gave non-monotone output?");
        }

        return ret;
    }

    !!/**
    !! * Produce a decomposition of weakly-simple polygon into convex components.
    !! * <br/><br/>
    !! * This algorithm 'should' be 100% robust and has been well test on for
    !! * example, the output of the Marching Squars utility which produces many
    !! * degenerate cases of weakly-simple polygons that have not yet broken this
    !! * algorithm!.
    !! * <br/><br/>
    !! * This algorithm operates in O(n.log(n)) time and will produce no more than
    !! * 4 times the number of convex poylgons in a minimal decomposition in the
    !! * worst case scenario.
    !! * <br/><br/>
    !! * Vertices may be stripped from the polygon that are found to not be
    !! * necessary as part of making this algorithm robust.
    !! *
    !! * @param delaunay This algorithm first performs a triangulation, if this field
    !! *                 is true, then this triangulation will be made delaunay and may
    !! *                 produce better convex polygons resultanly (default false).
    !! * @param output If supplied, polygons will be appended to this list via 'add'
    !! *        instead of a new list being constructed.
    !! * @return A Nape list of GeomPoly's defining the decomposition.
    !! * @throws # If polygon is degenerate.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function convexDecomposition(delaunay:Bool = false, output:GeomPolyList=null):GeomPolyList {
        Disposed(this, GeomPoly);
        DEBUG(
            if(size_lt_3) {
                throw "Error: Cannot decompose a degenerate polygon";
            }
        )

        var poly = PR(Monotone).decompose(verts, PR(Monotone).getShared());
        var MPs = poly.extract_partitions(PR(PartitionedPoly).getSharedPP());
        var ret = (output == null ? new GeomPolyList() : output);
        while (!MPs.empty()) {
            var MP = MPs.pop_unsafe();

            PR(Triangular).triangulate(MP);
            if (delaunay) {
                PR(Triangular).optimise(MP);
            }
            PR(Convex).optimise(MP);

            var MQs = MP.extract(PR(PartitionedPoly).getShared());
            Free(PR(PartitionedPoly), MP);

            while (!MQs.empty()) {
                var MQ = MQs.pop_unsafe();
                var x = GeomPoly.get();
                x.verts = MQ;
                ret.add(x);
                assert(x.isConvex(),"convex decomposition gave non-convex output?");
            }
        }

        return ret;
    }

    !!/**
    !! * Produce a decomposition of weakly-simple polygon into triangles.
    !! * <br/><br/>
    !! * This algorithm 'should' be 100% robust and has been well test on for
    !! * example, the output of the Marching Squars utility which produces many
    !! * degenerate cases of weakly-simple polygons that have not yet broken this
    !! * algorithm!.
    !! * <br/><br/>
    !! * This algorithm operates in O(n.log(n)) time.
    !! * <br/><br/>
    !! * Vertices may be stripped from the polygon that are found to not be
    !! * necessary as part of making this algorithm robust.
    !! *
    !! * @param delaunay If true, then an O(n^2) pass will be made to mutate the original
    !! *                 triangulation to push it into a delanuay triangulation. (default false)
    !! * @param output If supplied, polygons will be appended to this list via 'add'
    !! *        instead of a new list being constructed.
    !! * @return A Nape list of GeomPoly's defining the decomposition.
    !! * @throws # If polygon is degenerate.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function triangularDecomposition(delaunay:Bool=false,output:GeomPolyList=null):GeomPolyList {
        Disposed(this, GeomPoly);
        DEBUG(
            if(size_lt_3) {
                throw "Error: Cannot decompose a degenerate polygon";
            }
        )

        var poly = PR(Monotone).decompose(verts, PR(Monotone).getShared());
        var MPs = poly.extract_partitions(PR(PartitionedPoly).getSharedPP());
        var ret = (output == null ? new GeomPolyList() : output);
        while (!MPs.empty()) {
            var MP = MPs.pop_unsafe();
            PR(Triangular).triangulate(MP);
            if (delaunay) {
                PR(Triangular).optimise(MP);
            }

            var MQs = MP.extract(PR(PartitionedPoly).getShared());
            Free(PR(PartitionedPoly), MP);

            while (!MQs.empty()) {
                var MQ = MQs.pop_unsafe();
                var x = GeomPoly.get();
                x.verts = MQ;
                ret.add(x);
                assert(x.size()==3,"triangular decomosition gave non-triangle output?");
            }
        }

        return ret;
    }

    !!/**
    !! * Inflate/Deflate polygon.
    !! * <br/><br/>
    !! * This algorithm does not attempt to deal with any self-intersections which may
    !! * result from the process. Gaps are joined with a miter joint.
    !! * <br/><br/>
    !! * This algorithm will work for self-intersecting polygons, though the results
    !! * may not be what you expect; some parts will be inflated, and some deflated
    !! * depending on the local winding. You should probably avoid using this on
    !! * self-intersecting polygons.
    !! *
    !! * @param inflation The number of pixels to inflate polygon by. To deflate
    !! *                  use a negative value.
    !! * @return The inflated polygon.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function inflate(inflation:Float):GeomPoly {
        Disposed(this, GeomPoly);
        var ret = GeomPoly.get();
        if (isClockwise()) inflation = -inflation;

    mix_circular(PR(GeomVert),
        for_iter(p, verts, {
            var prev = p.prev;
            var next = p.next;

            vec_new(a);
            vec_new(b);
            vec_sub(p., prev., a);
            vec_sub(next., p., b);

            vec_new(ap);
            vec_new(bp);
            vec_set(ap, a); vec_normal(ap); vec_muleq(ap, inflation);
            vec_set(bp, b); vec_normal(bp); vec_muleq(bp, inflation);

            vec_new(bap); vec_sub(bp, ap, bap);
            var num = vec_cross(bap, b);
            var t = if (num == 0) 0 else (num / vec_cross(a, b));

            vec_new(p);
            vec_add(p., ap, p);
            vec_addeq(p, a, t);

            ret.push(Vec2.get(px, py));
        });
    )
        return ret.skipForward(1);
    }

    !!/**
    !! * Cut simple polygon with line.
    !! * <br/><br/>
    !! * The result of this operation will be a list of new GeomPoly representing
    !! * the connected regions of the polygon after an imaginary cut is made.
    !! * <pre>
    !! * (Result of cut assuming
    !! *  boundedStart = true)       _
    !! *   /&#92;    _             /&#92;   / &#92;
    !! *  /  &#92;  / &#92;           /  &#92; '---'
    !! * / o--&#92;/---&#92;-->  =>  /    &#92;,---,
    !! * &#92;_________/         &#92;_________/
    !! * </pre>
    !! * This algorithm runs in average case O(n.log(n)) time and worst case O(n^2).
    !! * For convex polygons, this algorithm runs in guaranteed O(n) time.
    !! *
    !! * @param start The start point for line segment
    !! * @param end The end point for line segment.
    !! * @param boundedStart If true, then the cut will not extend
    !! *                     beyond the start of the line segment.
    !! *                     (default false)
    !! * @param boundedEnd   If true, then the cut will not extend
    !! *                     beyond the end of the line segment.
    !! *                     (default false)
    !! * @param output A GeomPolyList to append results to if supplied,
    !! *               otherwise a new list is created (default null)
    !! * @return A list of GeomPoly representing the result of the cut.
    !! * @throws # If polygon is not simple.
    !! * @throws # If start or end Vec2 are null or disposed of.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function cut(
        start:Vec2,
        end:Vec2,
        boundedStart:Bool = false,
        boundedEnd:Bool = false,
        output:GeomPolyList = null
    ):GeomPolyList {
        Disposed(this, GeomPoly);
        DEBUG(
            if(!isSimple()) {
                throw "Error: Cut requires a truly simple polygon";
            }
            if(start==null || end==null) {
                throw "Error: Cannot cut with null start/end's";
            }
        )

        Disposed(start,Vec2);
        Disposed(end,Vec2);

        var ret = PR(Cutter).run(verts, start, end, boundedStart, boundedEnd, output);

        WEAK(start);
        WEAK(end);
        return ret;
    }

mix_circular(Vertex,
    !!/**
    !! * Transform polygon by given matrix.
    !! * <br/><br/>
    !! * Any transformation (not just equiorthogonal ones) are permitted, though
    !! * a transformation that causes polygon to be come degenerate is a bit
    !! * pointless.
    !! *
    !! * @param matrix The matrix to transform polygon by.
    !! * @return A reference to this polygon.
    !! * @throws # If matrix is null.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function transform(matrix:Mat23):GeomPoly {
        Disposed(this, GeomPoly);
        DEBUG(
            if (matrix == null) {
                throw "Error: Cannot transform by null matrix";
            }
        )

        for_iter(v, verts, {
            mat_transform_hom(matrix.,v.);
        });

        return this;
    }

    !!/**
    !! * Determine bounds of polygon.
    !! *
    !! * @return A new AABB representing bounds of polygon.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function bounds():AABB {
        Disposed(this, GeomPoly);
        DEBUG(
            if(empty()) {
                throw "Error: empty GeomPoly has no defineable bounds";
            }
        )

        vec_new(min, PR(Const).FMAX, PR(Const).FMAX);
        vec_new(max,-PR(Const).FMAX,-PR(Const).FMAX);
        for_iter(v, verts, {
            if(v.x < minx) minx = v.x;
            if(v.y < miny) miny = v.y;
            if(v.x > maxx) maxx = v.x;
            if(v.y > maxy) maxy = v.y;
        });

        return new AABB(minx, miny, maxx-minx, maxy-miny);
    }

    !!/**
    !! * Find top most vertex of polygon.
    !! * <br/><br/>
    !! * If there is more than one such vertex then the result is indeterminate.
    !! * <br/><br/>
    !! * The Vec2 returned is intrinsically tied to the inner vertex like that
    !! * returned by current(). This method will not alter the current vertex.
    !! * This Vec2 is not able to be disposed of.
    !! *
    !! * @return A Vec2 representing the top most vertex.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function top():Vec2 {
        Disposed(this, GeomPoly);
        DEBUG(
            if(empty()) {
                throw "Error: empty GeomPoly has no defineable topmost vertex";
            }
        )

        var min = verts;
        for_iter(v, verts.next, verts, if(v.y < min.y) min = v);

        return min.wrapper();
    }

    !!/**
    !! * Find bottom most vertex of polygon.
    !! * <br/><br/>
    !! * If there is more than one such vertex then the result is indeterminate.
    !! * <br/><br/>
    !! * The Vec2 returned is intrinsically tied to the inner vertex like that
    !! * returned by current(). This method will not alter the current vertex.
    !! * This Vec2 is not able to be disposed of.
    !! *
    !! * @return A Vec2 representing the bottom most vertex.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function bottom():Vec2 {
        Disposed(this, GeomPoly);
        DEBUG(
            if(empty()) {
                throw "Error: empty GeomPoly has no defineable bottommost vertex";
            }
        )

        var max = verts;
        for_iter(v, verts.next, verts, if(v.y > max.y) max = v);

        return max.wrapper();
    }

    !!/**
    !! * Find left most vertex of polygon.
    !! * <br/><br/>
    !! * If there is more than one such vertex then the result is indeterminate.
    !! * <br/><br/>
    !! * The Vec2 returned is intrinsically tied to the inner vertex like that
    !! * returned by current(). This method will not alter the current vertex.
    !! * This Vec2 is not able to be disposed of.
    !! *
    !! * @return A Vec2 representing the left most vertex.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function left():Vec2 {
        Disposed(this, GeomPoly);
        DEBUG(
            if(empty()) {
                throw "Error: empty GeomPoly has no defineable leftmost vertex";
            }
        )

        var min = verts;
        for_iter(v, verts.next, verts, if(v.x < min.x) min = v);

        return min.wrapper();
    }

    !!/**
    !! * Find right most vertex of polygon.
    !! * <br/><br/>
    !! * If there is more than one such vertex then the result is indeterminate.
    !! * <br/><br/>
    !! * The Vec2 returned is intrinsically tied to the inner vertex like that
    !! * returned by current(). This method will not alter the current vertex.
    !! * This Vec2 is not able to be disposed of.
    !! *
    !! * @return A Vec2 representing the right most vertex.
    !! * @throws # If polygon is empty.
    !! * @throws # If this GeomPoly has been disposed.
    !! */
    public function right():Vec2 {
        Disposed(this, GeomPoly);
        DEBUG(
            if(empty()) {
                throw "Error: empty GeomPoly has no defineable rightmmost vertex";
            }
        )

        var max = verts;
        for_iter(v, verts.next, verts, if(v.x > max.x) max = v);

        return max.wrapper();
    }
)
}
)
