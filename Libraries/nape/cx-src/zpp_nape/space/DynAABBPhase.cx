package zpp_nape.space;
$(import);

//since i use different 'next' variables, cannot use a MixList.
$(mixin iadd(list,obj,next) {
    assert(obj.next==null,"object already in list");
    obj.next = list;
    list = obj;
});
$(mixin ipop(list,next) ({
    assert(list!=null,"pop from empty list!");
    var ret = list;
    list = ret.next;
    ret.next = null;
    ret;
}));
$(mixin ierase(list,pre,cur,next) {
    assert(cur!=null,"cur = null");
    if(pre==null) list = cur.next;
    else pre.next = cur.next;
    cur.next = null;
});
$(mixin irem(list,obj,next) {
    var pre = null;
    var cur = list;
    while(cur!=null) {
        if(cur==obj) break;
        pre = cur;
        cur = cur.next;
    }
    ierase(list,pre,cur,next);
});

class PR(AABBNode) {
    //fattened AABB
    public var aabb :PR(AABB) = null;
    public var shape:PR(Shape) = null;

    //tree links
    public var dyn:Bool = false; //dtree or stree
    public var parent:PR(AABBNode) = null;
    public var child1:PR(AABBNode) = null;
    public var child2:PR(AABBNode) = null;

    //sub-tree height
    public var height:Int = 0;

    //used in ray casting for intersection time
    public var rayt:Float = 0.0;

    public function new() {
        height = -1;
    }

    MixPool(PR(AABBNode))
    flibmdel public inline function alloc() {
        Get(PR(AABB), aabb);
        moved = false;
        synced = false;
        first_sync = false;
    }
    flibmdel public inline function free() {
        height = -1;
        Free(PR(AABB),aabb);
        child1 = child2 = parent = null;
        next = null; snext = null; mnext = null;
    }

    //maintaining list of objects that have been re-inserted
    //for updating interaction pairs (vv)

    public var mnext:PR(AABBNode) = null;
    public var moved:Bool = false; //exists in move list.

    public var snext:PR(AABBNode) = null;
    public var synced:Bool = false; //exists in sync list.
    public var first_sync:Bool = false; //to avoid unnecessary work when syncing for the first time.

    flibmdel public inline function isLeaf() { return child1==null; }
}

class PR(AABBPair) {
    public var n1:PR(AABBNode) = null;
    public var n2:PR(AABBNode) = null;
    public var first:Bool = false;
    public var sleeping:Bool = false;

    //for lookups in shape lists of pairs.
    public var id:Int = 0;
    public var di:Int = 0;

    //optimisation to avoid second lookup if possible.
    public var arb:PR(Arbiter) = null;

    MixPool(PR(AABBPair))
    public function new() {}
    flibmdel public inline function alloc() {
        assert(arb==null,"node still has an arbiter when going into pool??");
    }
    flibmdel public inline function free () {
        assert(arb==null,"node still has an arbiter when going into pool??");
        n1 = n2 = null;
        sleeping = false;
    }
}

class PR(AABBTree) {
    public var root:PR(AABBNode) = null;
    public function new() {}

    //----------------------------------------------------------------------------------------------

      public function clear() {
        if(root==null) return;

        var stack:PR(AABBNode) = null;
        iadd(stack,root,next);
        while(stack!=null) {
            var node = ipop(stack,next);
            if(node.isLeaf()) {
                node.shape.node = null;
                node.shape.removedFromSpace();
                node.shape = null;
            }else {
                if(node.child1!=null) iadd(stack,node.child1,next);
                if(node.child2!=null) iadd(stack,node.child2,next);
            }
            Free(PR(AABBNode),node);
        }

        root = null;
    }

    public static var tmpaabb = new PR(AABB)();
    function insertLeaf(leaf:PR(AABBNode)) { inlined_insertLeaf(leaf); }
    flibmdel public inline function inlined_insertLeaf(leaf:PR(AABBNode)) {
        if(root==null) {
            root = leaf;
            root.parent = null;
        }else {
            var leafaabb = leaf.aabb;
            var node = root;
            while(!node.isLeaf()) {
                var child1 = node.child1;
                var child2 = node.child2;

                var area = node.aabb.perimeter();
                tmpaabb.setCombine(node.aabb,leafaabb);
                var carea = tmpaabb.perimeter();

                //cost of creating a new parent for this node and the new leaf
                var cost = 2*carea;
                //min. cost of pushing the leaf further down the tree
                var icost = 2*(carea - area);

                //cost of descending into child
                $(mixin cost_descend(child) ({
                    tmpaabb.setCombine(leafaabb,child.aabb);
                    if(child.isLeaf()) tmpaabb.perimeter() + icost;
                    else {
                        var oarea = child.aabb.perimeter();
                        var narea = tmpaabb.perimeter();
                        (narea - oarea) + icost;
                    }
                }));

                var cost1 = cost_descend(child1);
                var cost2 = cost_descend(child2);

                //descend according to min. cost
                if(cost < cost1 && cost < cost2) break;
                else node = cost1 < cost2 ? child1 : child2;
            }

            var sibling = node;

            //create a new parent
            var oparent = sibling.parent;
            var nparent; Get(PR(AABBNode), nparent);
            nparent.parent = oparent;
            nparent.aabb.setCombine(leafaabb,sibling.aabb);
            nparent.height = sibling.height + 1;

            if(oparent != null) {
                //sibling not the root
                if(oparent.child1 == sibling)
                     oparent.child1 = nparent;
                else oparent.child2 = nparent;

                nparent.child1 = sibling;
                nparent.child2 = leaf;
                sibling.parent = nparent;
                leaf.parent = nparent;
            }else {
                //sibling is the root.
                nparent.child1 = sibling;
                nparent.child2 = leaf;
                sibling.parent = nparent;
                leaf.parent = nparent;
                root = nparent;
            }

            //walk back up the tree fixing heights and aabbs
            node = leaf.parent;
            while(node != null) {
                node = balance(node);

                var child1 = node.child1;
                var child2 = node.child2;
                node.height = 1 + max(child1.height, child2.height);
                node.aabb.setCombine(child1.aabb,child2.aabb);

                node = node.parent;
            }
        }
    }

    public function removeLeaf(leaf:PR(AABBNode)) { inlined_removeLeaf(leaf); }
    flibmdel public inline function inlined_removeLeaf(leaf:PR(AABBNode)) {
        if(leaf==root) {
            root = null;
            return;
        }else {
            var parent = leaf.parent;
            var gparent = parent.parent;
            var sibling = if(parent.child1==leaf) parent.child2 else parent.child1;

            if(gparent != null) {
                //destroy parent and connect sibling to gparent
                if(gparent.child1==parent)
                     gparent.child1 = sibling;
                else gparent.child2 = sibling;
                sibling.parent = gparent;

                Free(PR(AABBNode),parent);

                //adjust ancestor bounds.
                var node = gparent;
                while(node != null) {
                    node = balance(node);

                    var child1 = node.child1;
                    var child2 = node.child2;

                    node.aabb.setCombine(child1.aabb,child2.aabb);
                    node.height = 1 + max(child1.height, child2.height);
                    node = node.parent;
                }
            }else {
                root = sibling;
                sibling.parent = null;

                Free(PR(AABBNode),parent);
            }
        }
    }

    flibmdel public inline function balance(a:PR(AABBNode)) {
        if(a.isLeaf() || a.height < 2) return a;
        else {
            var b = a.child1;
            var c = a.child2;

            //rotate b or c up, with childN corresponding to child1/child2 for b/c
            $(mixin rotate_up(rot,other, childN) {
                var f = rot.child1;
                var g = rot.child2;

                //swap a<->rot
                rot.child1 = a;
                rot.parent = a.parent;
                a.parent = rot;

                //a's old parent should point to rot
                if(rot.parent != null) {
                    if(rot.parent.child1 == a)
                         rot.parent.child1 = rot;
                    else rot.parent.child2 = rot;
                }else root = rot;

                //rotate
                $(mixin rotate(f,g) {
                    rot.child2 = f;
                    a.childN = g;
                    g.parent = a;
                    a.aabb.  setCombine(other.aabb,g.aabb);
                    rot.aabb.setCombine(a.aabb,    f.aabb);

                    a.  height = 1 + max(other.height, g.height);
                    rot.height = 1 + max(a.height,     f.height);
                });
                if(f.height > g.height)
                     rotate(f,g);
                else rotate(g,f);

                return rot;
            });

            var balance = c.height - b.height;
            if  (balance > 1) rotate_up(c,b,child2);
            elif(balance <-1) rotate_up(b,c,child1);
            else return a;
        }
    }

}

//Double Dynamic AABB tree.
class PR(DynAABBPhase) extends PR(Broadphase) {
    inline static var FATTEN = 3.0;
    inline static var VEL_STEPS = 2.0;

    //note kinematics are treat no differently here than dynamics
    public var stree:PR(AABBTree) = null; //for static/sleeping objects
    public var dtree:PR(AABBTree) = null; //for non-static, non-sleeping objects

    public var pairs:PR(AABBPair) = null; //intrusive list

    public var syncs:PR(AABBNode) = null; //intrusive list
    public var moves:PR(AABBNode) = null; //intrusice list

    public function new(space:PR(Space)) {
        this.space = space;
        is_sweep = false;
        dynab = this;

        stree = new PR(AABBTree)();
        dtree = new PR(AABBTree)();
    }

    //==============================================================

    flibmdel public inline function dyn(shape:PR(Shape)) {
        if(shape.body.isStatic()) return false;
        else return !shape.body.component.sleeping;
    }

    //==============================================================

    public function __insert(shape:PR(Shape)) {
        assert(shape.node==null,"shape has been inserted already");
        assert(shape.body!=null,"shape inserted with no body");

        var node; Get(PR(AABBNode), node);
        node.shape = shape;
        shape.node = node;

        //defer actual insertion until broadphase needs to be synced
        //makes sense to do this; as a shape may exist in the space
        //and then have transformations applied etc which would
        //required it to be re-synced again anyways.
        assert(!node.synced,"node is already in sync list?");
        node.synced = true;
        node.first_sync = true;
        iadd(syncs,node,snext);
    }
    public function __remove(shape:PR(Shape)) {
        assert(shape.body!=null,"do i need this assertion?");
        assert(shape.node!=null,"shape has no node?");

        var node = shape.node;
        //shape might not have been 'actually' inserted yet.
        if(!node.first_sync) {
            if(node.dyn) dtree.removeLeaf(node);
            else         stree.removeLeaf(node);
        }
        shape.node = null;

        //remove from sync list if waiting to be synced
        if(node.synced)    { irem(syncs,node,snext); node.synced = false; }
        if(node.moved)  { irem(moves,node,mnext); node.moved  = false; }

        //remove any pairs that may exist
        var pre = null;
        var cur = pairs;
        while(cur!=null) {
            assert(!cur.sleeping,"sleeping pair in pairs");
            var nxt = cur.next;
            if(cur.n1 == node || cur.n2==node) {
                if(pre==null) pairs    = nxt;
                else          pre.next = nxt;

                if(cur.arb!=null) cur.arb.pair = null;
                cur.arb = null;
                cur.n1.shape.pairs.remove(cur);
                cur.n2.shape.pairs.remove(cur);
                Free(PR(AABBPair),cur);

                cur = nxt;
                continue;
            }
            pre = cur;
            cur = nxt;
        }
        //clean up shape.pairs of any sleeping pairs that still remain!
        while(!shape.pairs.empty()) {
            var cur = shape.pairs.pop_unsafe();
            assert(cur.sleeping,"non-sleeping pair remaining after removing them from pairs");
            if(cur.n1==node) cur.n2.shape.pairs.remove(cur);
            else             cur.n1.shape.pairs.remove(cur);
            if(cur.arb!=null) cur.arb.pair = null;
            cur.arb = null;
            Free(PR(AABBPair),cur);
        }

        Free(PR(AABBNode),node);
    }
    flibmdel public inline function __sync(shape:PR(Shape)) {
        assert(!shape.body.isStatic(),"static shape being synced?");

        var node = shape.node;
        assert(node!=null,"shape has no node?");
        //defer syncing until it is necessary.
        if(!node.synced) {
            if (!space.continuous) shape.validate_aabb();

            //only sync if shape has changed mode (dyn/stat tree)
            //or has left it's fattened aabb
            var sync = node.dyn != dyn(shape) || !node.aabb.contains(shape.aabb);
            //var sync = !(node.dyn && node.aabb.contains(shape.aabb));
            if(sync) {
                #if NAPE_TIMES Debug.BROADCLASH++; #end
                node.synced = true;
                iadd(syncs,node,snext);
            }
            #if NAPE_TIMES Debug.BROADTOTAL++; #end
        }
    }

    //==============================================================
    /*
        In an effort to reduce runtime work, whenever possible
        the broadphase does not actually generate the moves list
        at all, and simply uses the syncs list.

        If this is not possible, then a constant switch is done
        and from that point on moves list is updated as per usual.
    */

    $(mixin syncnode(node) {
        var shape = node.shape;
        assert(node.synced,"node doesn't need syncing?");
        assert(shape.body!=null,"shape with no body can't be synced");

        //if this isn't the node's first sync, remove from tree.
        if(!node.first_sync) {
            var tree = if(node.dyn) dtree else stree;
            tree.inlined_removeLeaf(node);
        }else
            node.first_sync = false;

        var aabb = node.aabb;
        if (!space.continuous)
           shape.validate_aabb();
        aabb.setExpand(shape.aabb,FATTEN);

        //add a velocity contribution
/*
        vec_new(vel, shape.body.velx, shape.body.vely);
        var ang = shape.body.angvel;
        velx -= (shape.worldCOMy-shape.body.posy)*ang;
        vely += (shape.worldCOMx-shape.body.posx)*ang;

        ///make this based on space steps.
        vec_muleq(vel, space.pre_dt*VEL_STEPS);

        if(velx<0) aabb.minx += velx; else aabb.maxx += velx;
        if(vely<0) aabb.miny += vely; else aabb.maxy += vely;
*/
        //and insert/re-insert
        var tree = if(node.dyn=dyn(shape)) dtree else stree;
        tree.inlined_insertLeaf(node);
        node.synced = false;
    });

    public function sync_broadphase() {
        //validate shape aabb's and other properties.
        space.validation();

        if(syncs!=null) {
            if(moves==null) {
                var node = syncs;
                while(node!=null) {
                    syncnode(node);

                    //add to moves list, remove from syncs list.
                    assert(!node.moved,"node already moved apparently?");
                    node.moved = true;
                    node.mnext = node.snext;
                    node.snext = null;
                    node = node.mnext;
                }

                //final pointer swap
                swap(syncs,moves)
            }else
            {
                while(syncs!=null) {
                    var node = ipop(syncs,snext);
                    syncnode(node);

                    if(!node.moved) {
                        node.moved = true;
                        iadd(moves,node,mnext);
                    }
                }
            }
        }
    }

    public override function broadphase(space:PR(Space), discrete:Bool) {
        //finish syncing whatever is left to sync.
        var node = syncs;
        while(node!=null) {
            syncnode(node);
            node = node.snext;
        }

        //process moves + syncs list to generate new pairs.
        $(mixin proc(list,lnext) {
            while(list!=null) {
                var leaf = ipop(list,lnext);

                //handle rare instance of shape being in both syncs and moves list
                //ignore it and just handle once in moves.
                if($str(list)!="moves" && leaf.moved) continue;
                leaf.moved = false;

                var lshape = leaf.shape;
                var lbody = lshape.body;

                assert(!(lbody.component.sleeping && lbody.isStatic()),"a sleeping static?");
                if(lbody.component.sleeping) continue;

                var ab = leaf.aabb;
                var stack = null;
                $(mixin dotree(tree) {
                    if(tree.root!=null)
                        iadd(stack,tree.root,next);
                    while(stack!=null) {
                        var node = ipop(stack,next);
                        if(node==leaf) continue;

                        if(node.isLeaf()) {
                            var shape = node.shape;
                            if(shape.body != lshape.body && !(shape.body.isStatic() && lshape.body.isStatic())) {
                                if(ab.intersect(node.aabb)) {
                                    var id:Int; var di:Int;
                                    assert(lshape!=shape,"narrowphase area of dyn-aabb with same shape?");
                                    if(lshape.id < shape.id) { id = lshape.id; di = shape.id; }
                                    else                     { id = shape.id; di = lshape.id; }
                                    assert(id<di,"id's not well ordered in dyn-aabb narrowphase");
                                    var s = if(lshape.pairs.length<shape.pairs.length) lshape else shape;

                                    var p:PR(AABBPair) = null;
                                    Iter(px, s.pairs, {
                                        assert(!(px.id==di && px.di==id),"dyn-pair id didn't match shape id's");
                                        if(px.id == id && px.di == di) {
                                            p = px;
                                            break;
                                        }
                                    });

                                    if(p!=null) {
                                        if(p.sleeping) {
                                            p.sleeping = false;
                                            p.next = pairs;
                                            pairs = p;
                                            p.first = true; //avoid bounds check in main loop.
                                        }
                                        continue;
                                    }

                                    Get(PR(AABBPair), p);
                                    p.n1 = leaf;
                                    p.n2 = node;
                                    p.id = id; p.di = di;
                                    p.next = pairs;
                                    pairs = p;
                                    p.first = true; //avoid bounds check in main loop.

                                    lshape.pairs.inlined_add(p);
                                     shape.pairs.inlined_add(p);
                                }
                            }
                        }else if(ab.intersect(node.aabb)) {
                            if(node.child1!=null) iadd(stack,node.child1,next);
                            if(node.child2!=null) iadd(stack,node.child2,next);
                        }
                    }
                });

                dotree(dtree);
                dotree(stree);
            }
        });
        proc(syncs,snext)
        proc(moves,mnext)

        //process pairs (+ remove no longer valid pairs)
        var pre:PR(AABBPair) = null;
        var cur = pairs;
        while(cur!=null) {
            assert(!cur.sleeping,"non-sleeping pair in pairs");
            if(!cur.first && !cur.n1.aabb.intersect(cur.n2.aabb)) {
                if(pre==null) pairs = cur.next;
                else          pre.next = cur.next;
                cur.n1.shape.pairs.inlined_remove(cur);
                cur.n2.shape.pairs.inlined_remove(cur);
                var nxt = cur.next;
                if(cur.arb!=null) cur.arb.pair = null;
                cur.arb = null;
                Free(PR(AABBPair),cur);
                cur = nxt;
                continue;
            }
            var s1 = cur.n1.shape; var b1 = s1.body;
            var s2 = cur.n2.shape; var b2 = s2.body;
            if (!cur.first) {
                if((b1.component.sleeping || b1.isStatic())
                && (b2.component.sleeping || b2.isStatic())) {
                    cur.sleeping = true;
                    if(pre==null) pairs = cur.next;
                    else          pre.next = cur.next;
                    cur = cur.next;
                    continue;
                }
            }
            cur.first = false;
            if(s1.aabb.intersect(s2.aabb)) {
                assert(cur.arb==null || cur.arb.pair==cur, "arbiter/pair don't match up");
                var oarb = cur.arb;

                if (discrete)
                    cur.arb = space.narrowPhase(s1,s2,!b1.isDynamic() || !b2.isDynamic(), cur.arb, false);
                else
                    cur.arb = space.continuousEvent(s1,s2,!b1.isDynamic() || !b2.isDynamic(), cur.arb, false);

                if(cur.arb==null) {
                    if(oarb!=null) oarb.pair = null;
                }else
                    cur.arb.pair = cur;
                #if NAPE_ASSERT
                    if(cur.arb!=oarb)
                        assert(oarb==null || oarb.pair==null,"oh deary me");
                #end
            }

            pre = cur;
            cur = cur.next;
        }
    }

    //==============================================================

    //could DEFINATELY be improved, but not important right now
    public override function clear() {
        while(syncs!=null) {
            var next = syncs.snext;
            syncs.snext = null;
            if(syncs.first_sync) {
                syncs.shape.node = null;
                syncs.shape.removedFromSpace();
                syncs.shape = null;
            }
            syncs = next;
        }
        while(moves!=null) {
            var next = moves.mnext;
            moves.mnext = null;
            if(moves.first_sync) {
                moves.shape.node = null;
                moves.shape.removedFromSpace();
                moves.shape = null;
            }
            moves = next;
        }

        while(pairs!=null) {
            var nxt = pairs.next;
            if(pairs.arb!=null) pairs.arb.pair = null;
            pairs.arb = null;
            pairs.n1.shape.pairs.inlined_remove(pairs);
            pairs.n2.shape.pairs.inlined_remove(pairs);
            Free(PR(AABBPair),pairs);
            pairs = nxt;
        }

        dtree.clear();
        stree.clear();
    }

    //==============================================================

    //iterate tree, descending into a subtree only if condition is true
    //execute block on each leaf shape.
    var treeStack:List(PR(AABBNode)) = null;
    $(mixin IterTree(tree,condition,block) {
        if(tree.root!=null) {
            if (treeStack == null) treeStack = new List(PR(AABBNode))();
            treeStack.add(tree.root);
            while(!treeStack.empty()) {
                var node = treeStack.pop_unsafe();
                assert(node!=null,"null node");
                if(condition(node)) {
                    if(node.isLeaf()) {
                        block(node.shape);
                    }else {
                        if(node.child1!=null) treeStack.add(node.child1);
                        if(node.child2!=null) treeStack.add(node.child2);
                    }
                }
            }
        }
    });

    //==============================================================

    //iterate for leaves containing given point
    $(mixin IterPoint(tree,point,block) IterTree(tree,$(mixin cond(node) node.aabb.containsPoint(point)) cond, block));

    public override function shapesUnderPoint(x:Float,y:Float,filter:PR(InteractionFilter), output:ShapeList) {
        sync_broadphase();

        var v = PR(Vec2).get(x,y);
        var ret = (output == null ? new ShapeList() : output);

        $(mixin dotree(tree) {
            IterPoint(tree,v, $(mixin block(shape) {
                if(filter==null || shape.filter.shouldCollide(filter)) {
                    if(shape.isCircle()) {
                        if(PR(Collide).circleContains(shape.circle,v))
                            ret.push(shape.outer);
                    }else {
                        if(PR(Collide).polyContains(shape.polygon,v))
                            ret.push(shape.outer);
                    }
                }
            }) block)
        });
        dotree(stree)
        dotree(dtree)

        Free(PR(Vec2),v);
        return ret;
    }

    public override function bodiesUnderPoint(x:Float,y:Float,filter:PR(InteractionFilter), output:BodyList) {
        sync_broadphase();

        var v = PR(Vec2).get(x,y);
        var ret = (output == null ? new BodyList() : output);

        $(mixin dotree(tree) {
            IterPoint(tree,v, $(mixin block(shape) {
                var body = shape.body.outer;
                if(!ret.has(body)) {
                    if(filter==null || shape.filter.shouldCollide(filter)) {
                        if(shape.isCircle()) {
                            if(PR(Collide).circleContains(shape.circle,v))
                                ret.push(body);
                        }else {
                            if(PR(Collide).polyContains(shape.polygon,v))
                                ret.push(body);
                        }
                    }
                }
            }) block)
        });
        dotree(stree)
        dotree(dtree)

        Free(PR(Vec2),v);
        return ret;
    }

    //==============================================================

    //iterate over leaves intersecting given aabb
    $(mixin IterAABB(tree,AABB,block) IterTree(tree,$(mixin cond(node) node.aabb.intersect(AABB)) cond, block));

    public var treeStack2:List(PR(AABBNode)) = null;
    $(mixin IterRealAABB(tree,AABB,block,block2) {
        if(tree.root!=null) {
            if (treeStack == null) treeStack = new List(PR(AABBNode))();
            treeStack.add(tree.root);
            while(!treeStack.empty()) {
                var node = treeStack.pop_unsafe();
                assert(node!=null,"null node");
                if(AABB.contains(node.aabb)) {
                    if(node.isLeaf()) {
                        block2(node.shape);
                    }else {

                        //faster traversal.
                        if (treeStack2 == null) {
                            treeStack2 = new List(PR(AABBNode))();
                        }

                        treeStack2.add(node);
                        while(!treeStack2.empty()) {
                            var node = treeStack2.pop_unsafe();
                            if(node.isLeaf()) block2(node.shape);
                            else {
                                if(node.child1!=null) treeStack2.add(node.child1);
                                if(node.child2!=null) treeStack2.add(node.child2);
                            }
                        }

                    }
                }
                else if(node.aabb.intersect(AABB)) {
                    if(node.isLeaf()) {
                        block(node.shape);
                    }else {
                        if(node.child1!=null) treeStack.add(node.child1);
                        if(node.child2!=null) treeStack.add(node.child2);
                    }
                }
            }
        }
    });

    public override function shapesInAABB(aabb:PR(AABB), strict:Bool, containment:Bool, filter:PR(InteractionFilter), output:ShapeList) {
        sync_broadphase();
        updateAABBShape(aabb);

        var ab = aabbShape.pr(inner).aabb;
        var ret = (output == null ? new ShapeList() : output);

        $(mixin dotree(tree) {
            IterRealAABB(tree,ab, $(mixin block(shape) {
                if(filter==null || shape.filter.shouldCollide(filter)) {
                    if(strict) {
                        if(containment) {
                            if(PR(Collide).containTest(aabbShape.pr(inner),shape))
                                ret.push(shape.outer);
                        }else {
                            if(ab.contains(shape.aabb))
                                ret.push(shape.outer);
                            else if(PR(Collide).testCollide_safe(shape,aabbShape.pr(inner)))
                                ret.push(shape.outer);
                        }
                    }else if(!containment || ab.contains(shape.aabb))
                        ret.push(shape.outer);
                }
            }) block,
            $(mixin block2(shape) {
                if (filter == null || shape.filter.shouldCollide(filter)) {
                    ret.push(shape.outer);
                }
            }) block2
            )
        });
        dotree(stree)
        dotree(dtree)
        return ret;
    }

    public var failed:BodyList = null;
    public override function bodiesInAABB(aabb:PR(AABB), strict:Bool, containment:Bool, filter:PR(InteractionFilter), output:BodyList) {
        sync_broadphase();
        updateAABBShape(aabb);

        var ab = aabbShape.pr(inner).aabb;
        var ret = (output == null ? new BodyList() : output);
        if (failed == null) failed = new BodyList();

        $(mixin dotree(tree) {
            IterRealAABB(tree,ab, $(mixin block(shape) {
                var body = shape.body.outer;
                if (filter==null || shape.filter.shouldCollide(filter)) {
                    if (strict) {
                        if (containment) {
                            if (!failed.has(body)) {
                                var col = PR(Collide).containTest(aabbShape.pr(inner), shape);
                                if (!ret.has(body) && col) ret.push(body);
                                else if (!col) { ret.remove(body); failed.push(body); }
                            }
                        }
                        else if (!ret.has(body) && PR(Collide).testCollide_safe(shape,aabbShape.pr(inner))) {
                            ret.push(body);
                        }
                    }else {
                        if (containment) {
                            if (!failed.has(body)) {
                                var col = ab.contains(shape.aabb);
                                if (!ret.has(body) && col) ret.push(body);
                                else if (!col) { ret.remove(body); failed.push(body); }
                            }
                        }
                        else if (!ret.has(body) && ab.contains(shape.aabb)) {
                            ret.push(body);
                        }
                    }
                }

            }) block,
            $(mixin block2(shape) {
                if (filter == null || shape.filter.shouldCollide(filter)) {
                    var body = shape.body.outer;
                    if(!ret.has(body)) ret.push(body);
                }
            }) block2
            )
        });
        dotree(stree)
        dotree(dtree)

        failed.clear();
        return ret;
    }

    //==============================================================

    public override function shapesInCircle(x:Float,y:Float,r:Float, containment:Bool, filter:PR(InteractionFilter), output:ShapeList) {
        sync_broadphase();
        updateCircShape(x,y,r);

        var ab = circShape.pr(inner).aabb;
        var ret = (output == null ? new ShapeList() : output);

        $(mixin dotree(tree) {
            IterAABB(tree,ab, $(mixin block(shape) {
                if(filter==null || shape.filter.shouldCollide(filter)) {
                    if(containment) {
                        if(PR(Collide).containTest(circShape.pr(inner),shape))
                            ret.push(shape.outer);
                    } else if(PR(Collide).testCollide_safe(shape,circShape.pr(inner)))
                        ret.push(shape.outer);
                }
            }) block)
        });
        dotree(stree)
        dotree(dtree)
        return ret;
    }

    public override function bodiesInCircle(x:Float,y:Float,r:Float, containment:Bool, filter:PR(InteractionFilter), output:BodyList) {
        sync_broadphase();
        updateCircShape(x,y,r);

        var ab = circShape.pr(inner).aabb;
        var ret = (output == null ? new BodyList() : output);
        if (failed == null) failed = new BodyList();

        $(mixin dotree(tree) {
            IterAABB(tree,ab, $(mixin block(shape) {
                var body = shape.body.outer;
                if (filter==null || shape.filter.shouldCollide(filter)) {
                    if (containment) {
                        if (!failed.has(body)) {
                            var col = PR(Collide).containTest(circShape.pr(inner), shape);
                            if (!ret.has(body) && col) ret.push(body);
                            else if (!col) { ret.remove(body); failed.push(body); }
                        }
                    }
                    else if (!ret.has(body) && PR(Collide).testCollide_safe(shape,circShape.pr(inner))) {
                        ret.push(body);
                    }
                }
            }) block)
        });
        dotree(stree)
        dotree(dtree)
        failed.clear();
        return ret;
    }

    //==============================================================

    public override function shapesInShape(shp:PR(Shape), containment:Bool, filter:PR(InteractionFilter), output:ShapeList) {
        sync_broadphase();
        validateShape(shp);

        var ab = shp.aabb;
        var ret = (output == null ? new ShapeList() : output);

        $(mixin dotree(tree) {
            IterAABB(tree,ab, $(mixin block(shape) {
                if(filter==null || shape.filter.shouldCollide(filter)) {
                    if(containment) {
                        if(PR(Collide).containTest(shp,shape))
                            ret.push(shape.outer);
                    }else if(PR(Collide).testCollide_safe(shape,shp))
                        ret.push(shape.outer);
                }
            }) block)
        });
        dotree(stree)
        dotree(dtree)
        return ret;
    }

    public override function bodiesInShape(shp:PR(Shape), containment:Bool, filter:PR(InteractionFilter), output:BodyList) {
        sync_broadphase();
        validateShape(shp);

        var ab = shp.aabb;
        var ret = (output == null ? new BodyList() : output);
        if (failed == null) failed = new BodyList();

        $(mixin dotree(tree) {
            IterAABB(tree,ab, $(mixin block(shape) {
                var body = shape.body.outer;
                if (filter==null || shape.filter.shouldCollide(filter)) {
                    if (containment) {
                        if (!failed.has(body)) {
                            var col = PR(Collide).containTest(shp, shape);
                            if (!ret.has(body) && col) ret.push(body);
                            else if (!col) { ret.remove(body); failed.push(body); }
                        }
                    }
                    else if (!ret.has(body) && PR(Collide).testCollide_safe(shape,shp)) {
                        ret.push(body);
                    }
                }
            }) block)
        });
        dotree(stree)
        dotree(dtree)
        failed.clear();
        return ret;
    }

    //==============================================================

    public var openlist:List(PR(AABBNode)) = null;

    public override function rayCast(ray:PR(Ray),inner:Bool,filter:PR(InteractionFilter)) {
        if(openlist==null) openlist = new List(PR(AABBNode))();

        sync_broadphase();
        ray.validate_dir();
        var mint = ray.maxdist;

        $(mixin raynode(node) {
            if(node!=null) {
                if(ray.aabbtest(node.aabb)) {
                    var t = ray.aabbsect(node.aabb);
                    if(t>=0 && t<mint) {
                        node.rayt = t;
                        Insert(node, openlist, $(mixin lt(x,y) (x.rayt < y.rayt)) lt);
                    }
                }
            }
        });

        raynode(dtree.root);
        raynode(stree.root);

        var minres:RayResult = null;

        while(!openlist.empty()) {
            var cnode = openlist.pop_unsafe();
            if(cnode.rayt >= mint) break;

            if(cnode.isLeaf()) {
                var shape = cnode.shape;
                if(filter==null || shape.filter.shouldCollide(filter)) {
                    var result =
                        if(shape.isCircle()) ray.circlesect(shape.circle, inner,mint)
                        else if(ray.aabbtest(shape.aabb)) ray.polysect(shape.polygon,inner,mint);
                        else null;
                    if(result!=null) {
                        mint = result.distance;
                        if (minres != null) {
                            minres.dispose();
                        }
                        minres = result;
                    }
                }
            }else {
                raynode(cnode.child1);
                raynode(cnode.child2);
            }
        }

        openlist.clear();
        return minres;
    }

    public override function rayMultiCast(ray:PR(Ray),inner:Bool,filter:PR(InteractionFilter), output:RayResultList) {
        if(openlist==null) openlist = new List(PR(AABBNode))();

        sync_broadphase();
        ray.validate_dir();

        var inf = ray.maxdist >= PR(Const).POSINF();
        var ret = (output == null ? new RayResultList() : output);

        $(mixin raynode(node) {
            if(node!=null) {
                if(ray.aabbtest(node.aabb)) {
                    if(inf)
                        openlist.add(node);
                    else {
                        var t = ray.aabbsect(node.aabb);
                        if(t>=0 && t<ray.maxdist)
                            openlist.add(node);
                    }
                }
            }
        });

        raynode(dtree.root);
        raynode(stree.root);

        while(!openlist.empty()) {
            var cnode = openlist.pop_unsafe();
            if(cnode.isLeaf()) {
                var shape = cnode.shape;
                if(filter==null || shape.filter.shouldCollide(filter)) {
                    if(shape.isCircle()) ray.circlesect2(shape.circle,inner,ret);
                    else if(ray.aabbtest(shape.aabb))
                        ray.polysect2(shape.polygon,inner,ret);
                }
            }else {
                raynode(cnode.child1);
                raynode(cnode.child2);
            }
        }

        openlist.clear();
        return ret;
    }
}
